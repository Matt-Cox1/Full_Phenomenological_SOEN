# FILENAME: utils/activation_functions.py

import torch
import numpy as np
import torch.nn.functional as F




def gaussian_mixture(phi,s):
    """
    Gaussian mixture function for fitting.
    - Look in the csv that the `fit_activation_functions.py` script generates to get the parameters
    """
    # for ib=1.3524
    # A, mu_s, sigma_s, mu_phi, sigma_phi, B, C, D, E, F, G = [4.460299509680541, -1.7921979947541138, 3.0542445199794885, 0.6258305361534328, 0.3269684127136769, 0.02795144278218637, 106.72314709472433, 0.3498002444622292, 0.4125851135076629, -4.1807576234769686, -0.9975266453247964]
    
    # for ib = 1.5024
    # A, mu_s, sigma_s, mu_phi, sigma_phi, B, C, D, E, F, G = [0.45987940757620416, -0.11065312475577993, 0.742932017178216, 0.4594896049522472, 0.12564946756154163, 0.1565995939377978, 242.94532254158622, 0.31899361136400406, -0.025122359477096342, -0.023599731109540025, -0.005880585236135202]
    
    # for ib=1.65   
    # A, mu_s, sigma_s, mu_phi, sigma_phi, B, C, D, E, F, G = [0.6127821066912968, -0.20614274487639975, 0.7294642353846065, 0.44343395227212196, 0.16182960150587836, 0.23857055107033548, 197.21395122471577, 0.25226585332758744, -0.008608275075375583, -0.008669978655442685, -0.013890578685544368]

    # for ib = 1.7024
    A, mu_s, sigma_s, mu_phi, sigma_phi, B, C, D, E, F, G = [1.2697906839036404, -0.8704327310677562, 0.9451010053603051, 0.43969892684802053, 0.1849051479164699, 0.5259382498076823, 130.4453678725613, 0.22593566876025958, -0.02005403689674137, 0.0039458277719218345, -0.027308395661913065]
    
    # for ib = 1.9024:
    # A, mu_s, sigma_s, mu_phi, sigma_phi, B, C, D, E, F, G = [0.6775992002771366, -0.23739237632653604, 0.7744095397996802, 0.4088245781877772, 0.23550019250277088, 0.10289591806751208, 42.565738737377956, 0.1268487870417324, -0.00588017162694764, -0.0035795967728366844, -0.00945021063143129]
    
    # for ib=1.9524
    # A, mu_s, sigma_s, mu_phi, sigma_phi, B, C, D, E, F, G = [1.8902408292892448, -0.5793748399952492, 1.0076378039198572, 0.37696046230135816, 0.21724329681878674, 0.20097126408027727, 0.037733024301135065, -3.0549377178391772, -0.017757304825216185, 0.08829412741715986, -0.12631223724158575]
    
    # for 2.0024
    # A, mu_s, sigma_s, mu_phi, sigma_phi, B, C, D, E, F, G = [0.3183675193730303, 0.5350364141792108, 0.4237467726453815, 0.41038099673034667, 0.27228491624603246, -1.4119721077557958, 42.20306235659585, 0.04600075568525141, -0.009687640113186072, -0.010040320522303414, 0.0019016145784837935]

    # for ib=2.0524
    # A, mu_s, sigma_s, mu_phi, sigma_phi, B, C, D, E, F, G =[0.9743909032933316, -0.19241209903076917, 0.6727066781308906, 0.32826227080588966, 0.4689226349544368, 0.3856789301144915, 7.8588897779992095, 0.04536451814625961, -0.013324876062685672, 0.0005134292143923383, -0.014573315567206892]
    gaussian_s = torch.exp(-((s - mu_s)**2 / (2 * sigma_s**2)))
    gaussian_phi = torch.exp(-((phi - mu_phi)**2 / (2 * sigma_phi**2)))
    s_decay = torch.exp(-B * (s - 1)**2)
    phi_modulation = 1 / (1 + torch.exp(-C * (phi - D)))
    
    return torch.clamp(A * gaussian_s * gaussian_phi * s_decay * phi_modulation + E * s + F * phi + G, 0, 1)


def sigmoid_mixture(phi,s):
    """
    Sigmoid mixture function for fitting.
    Consistently worse then Gaussian Mixture - > Do not use this unless its MSE is lower
    """
    # for ib = 1.9024:
    # A1, mu_s, sigma_s, A2, mu_phi, sigma_phi, B, C, D, E = [-52.08826851798749, -3695.393331674093, -6694.1297408510645, -30.476772205388357, -0.0759768898163594, -0.05101434771115633, 0.07987935647831225, -0.5689420853786167, -1.2295302401112713, 10.464579789508592]
    
    # for ib=1.9524
    # A1, mu_s, sigma_s, A2, mu_phi, sigma_phi, B, C, D, E = [-83.37521368516022, -786.5577061430804, -2097.4695219668647, -44.642617408465334, 0.025957007552879576, -0.013210421737990967, 0.0397943262082278, -2.1009641836304978, 0.4796576000419657, 17.109850151045404]
   
    # for ib = 1.7024
    A1, mu_s, sigma_s, A2, mu_phi, sigma_phi, B, C, D, E =[-76.71391909673736, -1144.3573863768233, -1891.7867416668819, -14.000852275832397, 0.1194549318611177, -0.03297205685035558, 0.04860061062452471, -0.7285710977277362, 0.21710904734949343, 13.8593416343057]
   
   
   
   
   
    sigmoid_s = A1 / (1 + torch.exp(-(s - mu_s) / sigma_s))
    sigmoid_phi = A2 / (1 + torch.exp(-(phi - mu_phi) / sigma_phi))
    scaling = 1 / (1 + torch.exp(-B * (s + C * phi - D)))
    
    return torch.clamp((sigmoid_s + sigmoid_phi) * scaling + E, 0, 1)


def tanh_1d(phi, s):
    return torch.tanh(phi)

def relu_1d(phi, s):
    return F.relu(phi)

def tanh_2d(phi, s):
    return torch.clamp(0.5 * (torch.tanh(2 * phi.abs() - 2) + 1) - s*0.1, min=0, max=1)

def relu_2d(phi, s):
    return torch.clamp(phi.abs() - s, min=0)